import json, re, datetime
import requests, yaml
import concurrent.futures
from urllib3.exceptions import InsecureRequestWarning

yaml.warnings({'YAMLLoadWarning': False})

class Loader(object):

	def __init__(self, urls, config):
		self.urls = urls
		self.config = config

	def configReader(self):
		config = self.config
		with open(self.config, "r") as confs:
			data = yaml.load(confs)
		self.method = data["requests"][0]["method"]
		self.path = data["requests"][0]["path"][0].removeprefix("{{BaseURL}}")
		self.condition = data["requests"][0]["matchers-condition"]
		self.status = data["requests"][0]["matchers"][-2]["status"][0]
		self.matchers = data["requests"][0]["matchers"]
		self.severity = data["info"]["severity"]
		#print(self.path)
		for type_ in self.matchers:
			if type_["type"] == "status":
				self.status = type_["status"][0]
				print(self.status)
			elif type_["type"] == "word" and  type_["part"] == "header":
				self.word_h = type_["words"][0]
			elif type_["type"] == "word" and type_["part"] == "body":
				self.word_b = type_["words"][0]
			elif type_["type"] == "regex" and type_["part"] == "header":
				self.re_header = type_["regex"][0]
			elif type_["type"] == "regex" and type_["part"] == "body":
				self.re_body = type_["regex"][0]
				print(self.re_body)
			else:
				pass

	def requester(self):
		self.lists = []
		self.timeout = 20
		self.params =  None
		self.data = None
		with open(self.urls, "r") as urls:
			for url in urls:
				url = url.strip()
				self.lists.append(url)
		for url in self.lists:
			#: initiate loop
			#: print(*self.lists, end="\n")
			#: url = url + self.path
			#: print(url)
			try:
				if self.method ==  'GET':
					self.res = requests.get(url,params=self.params,allow_redirects=True,timeout=self.timeout,verify=False)
					if self.res.status_code == self.status and self.word_b in self.res.content.decode() and self.word_h in str(self.res.headers):
						return {
							"url":self.res.url,
							"code":self.res.status_code,
							"state": True,
							"severity": self.severity,
							"endpoint": self.path,
							"evidence": [{"headers": self.word_h, "body": self.word_b}]
							}
					else:
						return json.dumps({
								"status":self.res.status_code,
								"url":self.res.url,
								"state":False
								})

				elif self.method == 'PUT':
					self.res = requests.put(url,data=self.data,allow_redirects=True,timeout=self.timeout,verify=False)
					if self.res.status_code == self.status and self.word_b in self.res.content.decode() and self.word_h in self.res.headers:
						return  json.dumps({
							"url": self.res.url,
							"code": self.res.status_code,
							"state": True,
							"severity": self.severity,
							"endpoint": self.path,
							"evidence": [{"headers": self.word_h, "body": self.word_b}]
						}), print(self.res.content, self.res.headers)
					else:
						return json.dumps({
							"url": self.res.url,
							"state": False
						}), print(self.res.content, self.res.headers)
					print(self.res.status_code, self.res.ok)
				elif self.method == 'POST':
					self.res = request.post(url,data=self.data, allow_redirects=True,timeout=self.timeout,verify=False)
					if self.res.status_code == self.status and self.word_b in self.res.content.decode() and self.word_h in str(self.res.headers):
						return  json.dumps({
							"url":self.res.url,
							"code":self.res.status_code,
							"state":True,
							"severity": self.severity,
							"endpoint": self.path,
							"evidence": [{"headers": self.word_h, "body": self.word_b}]
						})
					else:
						return json.dumps({
							"url":self.res.url,
							"code":self.res.status_code,
							"state":False
						}),print(self.res.status_code, self.res.ok)
				else:
					pass
			except InsecureRequestWarning:
				pass

	def responser(self):
		if not self.re_body:
			if self.condition == "and":
				if self.res.status_code==self.status and self.word_b and self.word_h in self.res:
					return self.res.url
			elif self.condition == "or":
				if self.status and self.word_b or self.word_h in self.res:
					return self.res.url
			else:
				pass
		elif self.re_body:
			if self.condition == "and":
				if re.match(self.regex) and self.res.status_code == self.status:
					return self.res.url
				else:
					pass
			if self.condition == "or":
				if re.match(self.regex) and self.res.status_code == self.status:
					return self.res.url
		else:
			pass

